<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Test-Driven Development</title>

    <meta name="description" content="">
    <meta name="author" content="Benjamin Morgan">
    <meta name="author" content="Philipp Jeske">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <style>
        .reveal .slides li {
            padding-top: 0.5em;
        }

        .reveal .slides ol, .reveal .slides ul {
            padding-bottom: 0.75em;
        }
    </style>
    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
<div class="reveal">
<div class="slides">

<!--

    This is the Reveal framework: http://lab.hakim.se/reveal-js/
    For example slides see: https://github.com/hakimel/reveal.js/blob/master/index.html

    NOTE: I write my own slides in HTML5

-->

    <section id=title>
        <h1>Test-Driven Development</h1>
        <h3>(Testgetriebene Entwickelung)</h3>
        <p>
            <small>Benjamin Morgan, Philipp Jeske</small>
        </p>

        <aside class=notes>
            Philipp/Ben und ich wollen euch etwas über die testgetriebene
            Entwickelung erzählen, vielleicht besser bekannt als test-driven
            development, oder TDD.
        </aside>
    </section>

<!-- Einführung: Philipp -->
    <section id=problem>
        <h2>Das Problem</h2>

        <p>Aufgrund später Tests, unabsehbarer Nachbesserungsaufwand bei
        komplexen Projekten.</p>

        <aside class=notes>
            In der Softwareentwickelung geschieht es doch recht häufig, dass
            das Testen vernachlässigt, aufgeschoben oder gar übersprungen wird.
            Dies führt unweigerlich zu einer schlechteren Qualität der
            Software, und zu einer unabsehbaren Nachbesserungsaufwand. Das
            Problem wird nur noch schlimmer je mehr Leute an dem Projekt
            beteiligt sind. Das kann teuer werden.
        </aside>
    </section>

    <section id=loesung>
        <h2>Die Lösung</h2>

        <p>Früh in der Entwicklung Testen, am besten zeitgleich =&gt; TDD.</p>

        <aside class=notes>
            Die Lösung könnte sein, früh in der Entwicklung zu testen, ja sogar
            Zeitgleich mit dem Kodieren der Produktivcode. Man könnte ein
            Schritt weiter gehen, und fordern, dass die Tests vor der
            Produktivcode fertig sind. Dieser Ansatz nennt man die
            Testgetriebene Entwickelung.
    </section>

<!-- Definition: Ben -->
    <section id=definition>
        <h2>Test-Driven Development</h2>

        <p>Testgetriebene Entwickelung (TDD) ist ein Teil der <em>Agile</em>
        Softwareentwickelung, bestehend aus:</p>

        <ul style="margin-top: 0.5em">
            <li><em>test-first development</em> (TFD), und
            <li>häufiges Refaktorisieren.
        </ul>

        <aside class=notes>
            Test-Driven Development ist nicht eine Gesamtentwickelungsstrategie
            oder -philosophie, sondern nur ein Teil. Sie besteht aus:
            test-first development und häufiges Refaktorisieren.

            Hierbei ist das Refaktorisieren ein wesentlicher Teil der
            Strategie. Erstens, der erste Code den man schreibt ist in der
            Regel nicht der beste. Zweitens, erkennt man oft erst nach einiger
            Zeit den besten Ansatz. Dann sollte man aber refaktorisieren.

            Zusätzlich bringt TFD alleine nicht genug Vorteile und bringt
            sogar manche Nachteile mit sich, wenn man das Refaktorisieren
            weglässt. Wir werden später mehr dazu sagen.
        </aside>
    </section>

    <section id=zyklus>
        <h2>Kurzer iterativer Zyklus</h2>

        <ol>
            <li>Schreibe einen Test, der erstmal fehlschlägt.
            <li>Implementiere gerade so viel Produktivcode,
                dass der Test erfolgreich durchläuft.
            <li>Refaktorisiere den Test- und Produktivcode.
        </ol>

        <p style="font-size: 90%">
        Der ganze Zyklus soll etwa 3–15 Minuten dauern.</p>

        <aside class=notes>
            Wir wollen aber erstmal TDD ein bisschen genauer definieren.
        </aside>
    </section>

    <section>
        <section id=threelaws>
            <h2>Three Laws of Test-Driven Development</h2>

            <ol>
                <li>
                    You are not allowed to write any production code
                    unless it is to make a failing unit test pass.
                <li>
                    You are not allowed to write any more of a unit
                    test than is sufficient to fail; and compilation
                    failures are failures.
                <li>
                    You are not allowed to write any more production
                    code than is sufficient to pass the one failing
                    unit test.
            </ol>

            <aside class=notes>
                Eine andere Sicht auf die testgetriebene Entwickelung ist,
                sie als eine Menge von Regeln oder Gesetzen aufzufassen.
                Diese hier waren oft im Internet zitiert, und sind ziemlich
                klar.

                ...

                Der Entwickler reagiert nur auf fehlschlagende Tests.
            </aside>
        </section>

        <section id=fourthlaw>
            <h3>Fourth Law</h3>
            <p>Thou shalt write code that can be unit-tested.</p>

            <aside class=notes>
                Natürlich muss man ein Design haben und Code schreiben, dass
                Unittestbar ist.

                Was fehlt hier?
                Das kritische Refaktorisieren.
            </aside>
        </section>

        <section id=unclebob>
            <h4>For more from Uncle Bob:</h4>
            <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd">
                http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd
            </a>
        </section>
    </section>

    <section id=bemerkungen>
        <h2>Bemerkungen zu TDD</h2>

        <ul>
            <li>
                Es entstehen viele kleine Kontextwechsel zwischen
                Produktivcode und Testcode schreiben.
            <li>
                Das Konfigurationsmanagement sowie Entwicklungsumgebung
                spielen bei TDD eine große Rolle.
            <li>
                Ein signifikanter Nebeneffekt ist die Menge der erzeugten
                Tests, der in der Regel mindestens so groß wie der
                Produktivcode ist.
        </ul>
    </section>

<!-- Umsetzung: Philipp -->
    <section id=umsetzung>
        <h2>Umsetzung</h2>

        <p>
            Die Umsetzung erfolgt in der Praxis häufig mit Unit-Tests,
            mit unterschiedlich starker Mock-Repräsentation
        </p>
    </section>

<!-- Bewertung: Ben -->
    <section id=bewertung>
        <h2>Bewertung</h2>

        <aside class=notes>
            Wir wollen die Strategie „testgetriebene Entwickelung“
            bewerten.
        </aside>
    </section>

    <section>
        <section id=vorraussetzungen1>
            <h2>Vorraussetzungen</h2>

            <ul>
                <li>Das Management und Entwicklungsteam akzeptiert TDD.
                <li>Der Produktivcode ist testbar auf Basis von Unittests.
                <li>Die Spezifikation wird sich nicht signifikant ändern.
                    Es wird nicht zu heftig refaktoriert/überarbeitet.
            </ul>
        </section>

        <section id=vorraussetzungen2>
            <h3>Strikte Vorraussetzungen</h3>

            <ul>
                <li>Der Entwicklungsgegenstand hat einen klaren Ansatz
                    und erfordert wenig Experimentieren oder Prototyping.
                <li>Man kann den Entwicklungsgegenstand logisch in Module
                    zerteilen.
                <li>Es ist möglich, überall Dependency Injection anzuwenden
                    oder Objekte durch Mockobjekte zu ersetzen.
            </ul>
        </section>

        <section id=kompromiss>
            <h3>Was ist mit einem Kompromiss?</h3>

            <p>Es ist möglich eingeschränkt TDD anzuwenden; die Gefahr ist,
            dass man die schwer testbare Teile vom Codebase vernachlässigt.</p>
        </section>
    </section>

    <section>
        <section id=vorteile1>
            <h2>Vorteile [1/2]</h2>

            <ul>
                <li>TDD erzwingt ein testbares Design.
                <li>Hunderte und Tausende von Tests werden erzeugt.
                <li>Die Tests spezifizieren die Funktionalität eindeutig.
                <li>Die Tests dienen als Dokumentation und Beispielanwendungen.
            </ul>
        </section>

        <section id=vorteile2>
            <h2>Vorteile [2/2]</h2>

            <ul>
                <li>Man kann nach Belieben refaktorisieren, ohne versehentlich
                    Regressionen einzuführen.
                <li>Es gibt keinen Grund, „Angst“ vor dem Anfassen, Ändern oder
                    Löschen des Codes zu haben.
            </ul>
        </section>

        <section id=prophylaxe>
            <h3>TDD Als Prophylaxe</h3>
            <p>TDD beugt effektiv vor der menschliche Natur, genauer vor:</p>

            <ul>
                <li>Ausreden oder Abkürzungen um das Testen,
                <li>Gezwungenes Überspringen von Testphasen durch Management.
            </ul>
        </section>
    </section>

    <section>
        <section id=nachteilige_vorraussetzungen>
            <h2>Vorraussetzungen als Nachteile</h2>

            <p>Der Zusatzaufwand von TDD ist nicht Umsonst: TDD erfordert
            mehr Disziplin und Zeit von Entwicklern und muss gelernt werden.</p>

            <ul>
                <li>Manche Softwaregegenstände passen nicht leicht in TDD rein.
                <li>Änderungen an der Spezifikation sind teuer.
                <li>Das Management lässt sich oft nicht überzeugen, ganz in TDD
                    zu investieren.
                <li>Die Tests müssen über die gesamte Entwickelungsdauer
                    erhalten werden.
            </ul>
        </section>

        <section id=nachteile1>
            <h2>Andere Nachteile</h2>

            <ul>
                <li>TDD führt oft zu einem komplexeren Design.
                <li>Die Menge an erfolgreich durchlaufenden Tests kann falsche
                    Sicherheit herbeiführen; die Tests können Lücken aufweisen.
                <li>TDD kann den Produktivcode schnell in ein vorläufiges Design
                    fixieren.
            </ul>
        </section>
    </section>

<!-- Fazit: Philipp -->
    <section id=fazit>
        <h2>Fazit</h2>

        <p>Keine allgemeine Empfehlung möglich, immer eine
        Einzelfallentscheidung</p>
    </section>

<!-- Beispiel: Philipp -->
    <section>
        <section id=beispiele>
            <h2>TDD einsetzen oder nicht?</h2>
        </section>

        <section id=beispiel1>
            <h2>Beispiel 1</h2>
            <p>Es soll eine neue Version eines Autopiloten entwickelt werden.
            Der Autopilot legt anhand von Zielwerten und Messwerten, wie
            Windgeschwindigkeit, -richtung, Luftdruck, GPS etc., die Winkel der
            Steuerflächen und die Leistung der Turbinen fest. Das Management
            fordert eine hohe Qualität und überprüfbare Korrektheit, damit eine
            Zulassung für den Luftverkehr erfolgen kann.  </p>
        </section>

        <section id=beispiel2>
            <h2>Beispiel 2</h2>
            <p>Es soll eine Applikation entwickelt werden, die über das
            Netzwerk auf eine Datenbank zugreift und für eine GUI die
            CRUD-Operationen bereitstellt. Der Kunde möchte damit ein
            existierendes System ablösen und seinen Workflow verbessern. Es
            soll auf einem für das Unternehmen neuen Framework aufbauen und
            Teilberechnungen sollen über eine proprietäre Drittsoftware
            umgesetzt werden. Um die Akzeptanz der Anwender zu steigern, werden
            diese regelmäßige nach Verbesserungsvorschlägen befragt.</p>
        </section>
    </section>

<!-- Ende -->
    <section>
        <section id=danke>
            <h2>Vielen Dank fürs Zuhören!</h2>
        </section>

        <section id=fragen>
            <h2>Fragen?</h2>
        </section>
    </section>
</div>
</div>

<!-- Endmatter -->

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>
<script>
    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme || 'solarized', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
            { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
            { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
    });
</script>
</body>
</html>
